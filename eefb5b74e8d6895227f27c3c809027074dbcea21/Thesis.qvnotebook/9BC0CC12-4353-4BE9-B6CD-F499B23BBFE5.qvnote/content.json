{
  "title": "TrAtiyah.hs",
  "cells": [
    {
      "type": "markdown",
      "data": "**please never share this code... it is code that only a mother could love**"
    },
    {
      "type": "code",
      "language": "haskell",
      "data": "module TrAtiyah where\n\nimport Data.Ratio\nimport Data.List\nimport Data.Ord      (comparing)\nimport Data.Tuple    (fst, snd)\nimport Data.Function (on)\nimport Data.Char     (digitToInt)\nimport Data.Maybe    (fromJust)\n\nimport Math.LinearEquationSolver\n-- this comes from the linearEqSolver package on hackage\n-- we also use the CVC4 solver\nimport System.IO.Unsafe (unsafePerformIO)\n\n\n\n\ntype AMonomial   = (Rational, [Int])\n-- e.g. (1%2, [1,1,3,3]) corresponds to 1/2 * A_1^2 * A_3^2\ntype APolynomial = [AMonomial]\n-- a list of monomials corresponds to their sum\n\ntype BMonomial   = (Rational, [(Int, Int)])\n-- e.g. (1%2, [(0,1),(1,2)]) corresponds to 1/2 * (A_1-A_0) * (A_2-A_1)\n-- n.b. B_{m,n} = A_n - A_m\ntype BPolynomial = [BMonomial]\n-- a list of monomials corresponds to their sum\n\ntype FullVector = [(Rational, String)]\n\n\n\n\naa :: Int -> AMonomial\naa m = (1, [m])\n\nbb :: Int -> Int -> BMonomial\nbb m n = (1, [(m, n)])\n\ntrAtiyah :: Int -> BPolynomial\ntrAtiyah n = (1, zip [0..n-1] [1..n]) : []\n\n\n\n\nconvertBMtoAP :: BMonomial -> APolynomial\nconvertBMtoAP bm = [ ((fst am) * (fst bm), snd am) | am<-productWithoutCoeff] \n    where productWithoutCoeff = simplifyAP\n                                $ foldr1 multiply2AP\n                                $ map simplifyAP\n                                $ [ [aa n, minusA $ aa m] | (m,n)<-(snd bm) ]\n\n\n\n\nminusA :: AMonomial -> AMonomial\nminusA m = (negate $ fst m, snd m)\n\nminusB :: BMonomial -> BMonomial\nminusB m = (negate $ fst m, snd m)\n\n\n\n\nallCyclicPermutations :: [a] -> [(Int, [a])]\nallCyclicPermutations xl = take (length xl) $ zip [0..]\n                           $ iterate (\\(x:xs) -> xs ++ [x]) xl\n\nlowestCyclicPermutation :: (Ord a) => [a] -> (Int, [a])\nlowestCyclicPermutation m = minimumBy (comparing snd) $ allCyclicPermutations m\n\nsimplifyPermutationAM :: AMonomial -> AMonomial\nsimplifyPermutationAM m = (newcoef, newmon)\n    where coefmod = (*) ((+) 1 $ length . snd $ m)\n                        (fst . lowestCyclicPermutation . snd $ m)\n          newcoef = (*) ((-1)^coefmod) $ fst m\n          newmon  = snd . lowestCyclicPermutation . snd $ m\n\nsimplifyAdditionAP :: APolynomial -> APolynomial\nsimplifyAdditionAP = dropZeros . addMonomials\n    where addMonomials ap = map (\\l -> (foldr1 (+) $ map fst l, snd $ l!!0))\n                            $ groupBy ((==) `on` snd) . sortBy (comparing snd)\n                            $ ap\n          dropZeros ap    = [m | m <- ap, (fst m)/=0,\n                                          not . zeroTrace $ snd m,\n                                          not . elem 0 $ snd m]\n          zeroTrace m\n                  | odd . length $ m                   = False\n                  | intersect evenPerms oddPerms /= [] = True\n                  | otherwise                          = False\n              where oddPerms  = map snd $ filter (odd . fst) $ allPerms\n                    evenPerms = map snd $ filter (even . fst) $ allPerms\n                    allPerms  = allCyclicPermutations m\n\nsimplifyAP :: APolynomial -> APolynomial\nsimplifyAP = simplifyAdditionAP . map simplifyPermutationAM\n\n\n\n\nsimplifyBP :: BPolynomial -> BPolynomial\nsimplifyBP bp = [bm | bm<-bp, (fst bm)/=0]\n\n\n\n\nmultiply2AM :: AMonomial -> AMonomial -> AMonomial\nmultiply2AM m m' = ((fst m)*(fst m'), concat [snd m, snd m'])\n\nmultiply2AP :: APolynomial -> APolynomial -> APolynomial\nmultiply2AP p p' = map (foldr1 multiply2AM)\n                             $ map (zipWith (\\l n -> l!!n) [p,p']) allCombos\n    where simplep   = simplifyAdditionAP p\n          simplep'  = simplifyAdditionAP p'\n          allCombos = sequence $ map (\\x->[0..x-1]) $ map length [p,p']\n\n\n\n\nmDeRhamD :: AMonomial -> APolynomial\nmDeRhamD am = zip altSignCoeffs leibnitzList\n    where altSignCoeffs = map (* (fst am)) $ map ((^) (-1)) [1..]\n          leibnitzList  = zipWith (++)\n                          (tail . inits $ snd am)\n                          (init . tails $ snd am)\n\ndeRhamD :: APolynomial -> APolynomial\ndeRhamD ap = simplify . concat $ map mDeRhamD ap\n    where simplify = simplifyAP\n\n\nmCechD :: Int -> BMonomial -> APolynomial\nmCechD k bm = simplifyAP $ concat\n           $ map convertBMtoAP\n                     $ zipWith ($) (cycle [id, minusB])\n                     $ zip (repeat . fst $ bm) cechList\n    where cechList = map (\\vs -> [ (vs!!x, vs!!y) | (x,y)<-(snd bm) ])\n                     $ zipWith (++) (inits [0..(k+1)]) (tail $ tails [0..(k+1)])\n\n-- here the degree k is the number of variables, since a Cech k-cycle\n-- is given by (k+1) elements, but all of our A_j are \\omega_{i,j}, and so we\n-- only need k variables to get a Cech k-cycle\n\n\n\n\n\nuniqueMonomialsAsNumbers :: Int -> Int -> [String]\nuniqueMonomialsAsNumbers k d = nub $ map (snd) $ map lowestCyclicPermutation\n                             $ mapM (const stringOfVariables) [1..d]\n        where stringOfVariables = concat $ map (show) [1..k]\n\nnumberStringToBM :: String -> BMonomial\nnumberStringToBM xs = (1, map turnDigitIntoPolynomial xs)\n    where turnDigitIntoPolynomial x\n            | x=='1'    = (0::Int,1::Int)\n            | otherwise = (1::Int,digitToInt x)\n\nuniqueMonomialsAsBM :: Int -> Int -> [BMonomial]\nuniqueMonomialsAsBM k d =\n    map numberStringToBM $ uniqueMonomialsAsNumbers k d\n\n\n\n\nconvertAPtoFV :: Int -> Int -> APolynomial -> FullVector\nconvertAPtoFV k d p = sortBy (comparing snd) unsortedVector\n    where basis = uniqueMonomialsAsNumbers k d\n          pAsString = [(c, concat . (map show) $ m) | (c,m)<-p]\n          missing = basis \\\\ map snd pAsString\n          missingWithCoefficients = [(0,m) | m<-missing]\n          unsortedVector = pAsString ++ missingWithCoefficients\n-- here k and d are the same as in mCechD\n\n\n\n\ntoAugmentedMatrix :: [FullVector] -> FullVector -> ([[Rational]], [Rational])\ntoAugmentedMatrix c r = (coeffs, result)\n    where coeffs = map (map toRational) $ transpose $ map (map fst) c\n          result = map toRational $ map fst r\n\nsolveAugmentedMatrix :: ([[Rational]], [Rational]) -> [Rational]\nsolveAugmentedMatrix am = unsafePerformIO $ fmap fromJust\n                          $ solveRationalLinearEqs CVC4 (fst am) (snd am)\n\nresubSolOnPreimage :: [BMonomial] -> [Rational] -> BPolynomial\nresubSolOnPreimage bl rl = map scale $ zip bl rl\n    where scale = \\(m,r)->(r * fst m, snd m)\n\n\n\n\n-- We want to call this with k = d = p for the p-th atiyah class,\n-- and then call this with k = k-1, d=d+1 for the result of the above, etc.\ndeRhamInverseCechBP :: Int -> Int -> BPolynomial -> BPolynomial\ndeRhamInverseCechBP k d bp = simplifyBP\n                             $ resubSolOnPreimage uniqueMons $ solution\n    where uniqueMons = uniqueMonomialsAsBM (k-1) (d+1)\n          solution   = solveAugmentedMatrix mat\n          mat        = toAugmentedMatrix vl dp\n          vl         = map (convertAPtoFV k (d+1))\n                       $ map (mCechD (k-1)) uniqueMons\n          dp         = convertAPtoFV k (d+1)\n                       $ deRhamD . simplifyAP . concat\n                       $ map convertBMtoAP bp\n\n\n\n\ncomputeRepresentative :: Int -> [BPolynomial]\ncomputeRepresentative p = scanl (flip ($)) (trAtiyah p) list\n    where list = map (uncurry deRhamInverseCechBP)\n                 $ zip [p,(p-1)..2] [p..(2*p-2)]\n"
    },
    {
      "type": "markdown",
      "data": "![IMAGE](quiver-image-url/55DAEE23BA151905779E547A11B0C576.jpg =2090x678)"
    }
  ]
}